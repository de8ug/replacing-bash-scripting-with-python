用Python替换Bash脚本

如果我没有涵盖您想要了解的内容或者您发现其他问题，请打开一个问题   github ！

内容

介绍
如果壳牌太棒了，问题是什么？
为何选择Python？
学习Python
读写文件
Python中的命令行界面
与...合作   斯坦丁 ，   标准输出   和   标准错误
CLI参数
环境变量和配置文件
文件系统的东西
路径
替换杂项文件操作：   shutil
更换   sed ，   grep ，   awk 等：Python正则表达式
如何   grep的
示例：搜索日志以查找错误
如何   SED
如何   AWK
运行进程
处理退出代码
重定向进程IO（即管道）
该   标准错误   参数
后台进程和并发
shlex.quote ：防止外壳注入
杂
获得时间
进程间通信
下载网页和文件
介绍

Unix shell是我最喜欢的发明之一。 这是天才，简单明了。 这个想法是用户环境是图灵完备的声明性编程 语言。 它有一个用于处理I / O和并发的死简单模型，这在其他大多数语言中都是非常困难的。

对于数据可以表示为由换行符分隔的类似对象流以通过一系列过滤器同时处理并处理大量I / O的问题，很难想到比shell更理想的语言。 Unix或Linux系统上的许多核心部件旨在以这种格式表达数据。

如果壳牌太棒了，问题是什么？

问题是如果你想做其他任何事情，例如写逻辑，使用控制结构，处理复杂数据......你将遇到大问题。 当Bash协调外部程序时，它太棒了。 当它自己做任何工作时，它会分解成一堆垃圾。

对我来说，Bash和其他shell方言的基本问题是文本是标识符，标识符是文本 - 基本上其他一切也都是文本。 在某种意义上，这使得shell成为一种同性语言，理论上它意味着它可能有一个有趣的元编程故事，直到你意识到它基本上只是运行   EVAL   在字符串上，这是当今基本上任何解释语言的一个特征，并且经常被认为是有害的。 这个问题   EVAL   这是任意代码执行的直接途径。 如果任意代码执行实际上是你想要完成的（例如，在HTML模板引擎中），这是很好的，但它通常不是你想要的。

Bash基本上默认为评估所有内容。 这对于交互式使用非常方便，因为当您真正想要做的就是在文本编辑器中打开文件时，它会减少对大量显式语法的需求。 这在脚本环境中非常糟糕，因为它将整个语言转换为注入蜜罐。 是的，一旦你知道了技巧，就可以并且不那么难以写出安全的Bash，但它需要额外的考虑而且很容易忘记或者对它很懒惰。 写三四行安全Bash很容易; 两百个更具挑战性。

Bash还有其他问题。 Bourne Shell不是原生的语法，感觉非常丑陋和疯狂。 例如，大多数现代shell都有数组。 让我们看一下迭代数组的语法，但让我们在那里走得很远。

$ foo = '这个和那个' #variable assignment

$ echo $ foo

这个和那个

$ ＃哦亲爱的。 变量内的文本被拆分为参数

$ ＃whitespace，因为eval所有的东西。

$

$ ＃为了避免这种疯狂的行为，做一件显而易见的事：使用字符串

$ ＃interpolation。 :-(

$ echo “ $ foo ”

这个和那个

这与迭代数组有什么关系？ 不幸的是，答案是“某种东西”。

要正确迭代数组中的字符串（数组可能包含的唯一内容），您还可以使用变量插值语法。

在 项目 “ $ {my_array [@]} ” ; 做

“ $ item ”的 东西

DONE

为什么字符串插值语法会被用于迭代数组中的项目？ 我有一些理论，但他们只是那样。 我可以告诉你，但它不会使这种语法变得不那么糟糕。 如果你对Bash不太熟悉，你也可能（正确地）想知道这是什么   @   是，或为什么一切都在花括号。

所有这些问题的答案或多或少都是因为他们不想做任何会破坏与没有这些功能的古老Unix shell脚本兼容的事情。 所有的东西都是用你能想象到的最奇怪的语法。 Bash实际上具有现代编程语言的许多功能，但问题在于提供访问它们的语法完全违背逻辑并且由遗留问题决定。

Bash IRC频道有一个非常有用的机器人，greybot，由一个更重要的Bash社区成员和专家greycat编写。 这个机器人是用Perl编写的。 我曾经问过为什么它不是用Bash写的，只有一个答案：“greycat想要保持理智。”

实际上，这个答案应该足够了。 你想保持理智吗？ 您是否希望将来维护您的代码的人不要诅咒您的名字？ 不要使用Bash。 参与抗击精神疾病的斗争。

为何选择Python？

没有特别的原因。   Perl的   和   红宝石   也是灵活，易于编写的语言，具有对管理脚本和自动化的强大支持。 我建议初学者使用Perl，因为它与Bash有一些类似的问题：它在创建时是一个小得多的语言，并且新功能的许多语法都有一种狂热的感觉   [1] 。 但是，如果一个人对Perl了解得很好并且对它感到满意，那么它非常适合这项任务，对于非平凡的自动化脚本来说仍然是一个更加理智的选择，而且这是其最强大的领域之一。

Node.js的   这些天也开始用于管理工作，所以这也可以是一个选项，尽管JavaScript与Perl有类似的问题。 我一直在调查使用的可能性   朱莉娅   为此。 无论如何，大多数解释型语言似乎都支持这种类型的东西，你应该选择一个你喜欢的语言，并且可以在Linux和其他* nix操作系统上广泛使用。

我推荐Python的主要原因是你已经知道了。 如果除了BASH（或BASH以及像C或甚至Java这样的低级语言）之外你什么都不知道，Python是你下一种语言的合理选择。 它在很多领域都有很多成熟，快速的第三方库 - 科学，数学，网络，机器学习等。它通常被认为易于学习，并已成为一种主要的教学语言。

学习Python的另一个非常令人信服的理由是它是这个非常引人注目的教程所涵盖的语言。

[1]

我在这里专指Perl 5。 在我看来，Perl 6是一种更好的语言，但是缺乏采用。 https://perl6.org/

学习Python

本教程不会教您Python核心语言，但会介绍一些内置功能。 如果你需要学习它，我强烈推荐   官方教程 ，至少通过第5章。通过第9章会更好，你也可以在这一点上阅读整篇文章。

如果您是编程新手，可以试试这本书   介绍Python   也许   想想Python 。   潜入Python   是另一本可在线免费获得的畅销书。 您可能会看到很多建议   以艰难的方式学习Python 。 我认为这种方法是有缺陷的，但我确实感谢它是由对正确性有强烈意见的人写的，这有一些好处。

本教程假定Python 3.5或更高版本，虽然有时可能会使用较新版本的习惯用法，但我会尝试记录何时使用了3.4中不起作用的习惯用法，这显然是最新的CentOS和SLES附带的版本。 如果可以的话，至少使用3.6。 它有一些很酷的新功能，但是在这个版本的Python中也对字典的实现（Python的哈希映射）进行了全面改进，这有点像整个对象系统的实现方式，因此是一个重大的胜利。

基本上，总是尝试使用最新版本的Python。 不要使用Python 2.它将在2020年正式退役。那是两年。 如果一个库尚未移植到Python 3，它已经死了，只是它的维护者可能还不知道它。

关于本教程的最后一点说明：它没有解释   这么多 。 我不想重写官方文档中已有的内容。 对于那些希望执行Bash脚本常用任务的人来说，它经常只指向相关文档。

读写文件

如果您要在Unix系统上进行任何类型的管理或自动化，那么使用文件的想法就非常重要。 伟大的coreutils就像   grep ，   sed ，   awk ，   tr ，   排序 等等，它们都被设计为逐行遍历文本文件并执行...具有该行内容的东西。 任何shell脚本编写者都知道这些“文件”并不总是真正的文件。 通常不这样做，它实际上处理的是另一个进程的输出而不是文件。 无论来源如何，组织原则都是由换行符分隔的文本流。 在Python中，这就是我们称之为“类文件对象”。

因为使用文本流的想法对于Unix编程来说是如此重要，所以我们开始本教程的基础是使用文本文件，并将从那里到你可能想要使用的其他流。

shell中的一个方便之处是你永远不需要文件句柄。 所有你必须键入以循环文件中的行将是这样的：

而 读 线 ; 做

“ $ line ”的 东西

DONE < my_file.txt

（不要使用这个代码。你实际上必须用$ IFS来做一些使它安全的事情。不要使用我的任何Bash示例。不要使用Bash！正确的是   而IFS =读取-r行 ，但这只会引发更多问题。）

在Python中，您需要将路径转换为文件对象。 上面的循环将是这样的：

同 打开 （ 'my_file.txt' ） 作为 my_file：

    在 my_file 行 ：

do_stuff_with（line.rstrip（））

 

## .rstrip（）方法是可选的。 它删除尾随空格

##从行（包括换行符）。

让我们分开吧。

该   打开（）   function返回一个文件对象。 如果您只是将路径名作为字符串发送给它，它会假设它是一个默认系统编码的文本文件（UTF-8，对吗？），它只会打开以供阅读。 当然，你可以这样做   my_file = open（'my_file.txt'）   同样。 当你使用   用x作为y：   而不是赋值，它确保在使用称为“上下文管理器”的东西退出块时正确清理对象。 你可以做   my_file.close（）   手动，但是   with block将确保即使您在不必编写大量额外代码的情况下遇到错误也会发生这种情况。

关于上下文管理器的重要之处在于它们增加了额外的缩进级别。 这是一个辅助函数，您可以使用它来打开上下文管理器，以便在循环后打开要清理的内容。

高清 iter_with （obj）：

    与 obj：

        来自 obj的 收益率

然后你像这样使用它：

在 iter_with 线 （ 开 （ 'my_file.txt'））：

do_stuff_with（线）

产量来自   意味着它是一个   生成器函数 ，它将控制权移交给子迭代器（在这种情况下为文件对象），直到迭代器用完了要返回的东西。 如果没有意义，请不要担心。 这是一个更高级的Python主题，对于管理脚本而言不是必需的。

如果你不想在行上进行迭代，这是处理文本文件最有效的内存方式，你可以像这样一次啜饮文件的全部内容：

同 打开 （ 'my_file.txt' ） 作为 my_file：

file_text = my_file.read（）

    ＃＃ 要么

lines = list （my_file）

    ##或删除了换行符

lines = my_file.read（）。splitlines（）

 

##此代码实际上不会运行，因为该文件尚未运行

##在读完之后重新开始。

 

##另请注意：list（my_file）。 任何采用迭代的函数都可以

##带一个文件对象。

您也可以打开文件进行编写，如下所示：

同 打开 （ 'my_file.txt' ， 'w' ） 作为 my_file：

my_file.write（ 'some text \ n' ）

my_file.writelines（[ 'a \ n' ， 'b \ n' ， 'c \ n' ]）

    print （ 'another line' ， file = my_file）#print 添加换行符。

第二个论点   打开（）   是个   模式 。 默认模式是   'r' ，用于打开文本以读取文本。   'W'   删除文件中的所有内容（如果文件不存在则创建它）并打开它进行写入。 您也可以使用该模式   'a' 。 这将转到文件的末尾并在那里添加文本。 在shell方面，   'R'   有点像   < ，   'W'   有点像   > ，和   '一个'   有点像   >> 。

这只是你可以用文件做的开始。 如果您想了解他们的所有方法和模式，请查看官方教程的部分   读写文件 。 文件对象提供了很多很酷的界面。 这些接口将与其他“类文件对象”一起返回，这些对象将在以后出现很多次，包括在下一节中。

Python中的命令行界面

与...合作   斯坦丁 ，   标准输出   和   标准错误

Unix脚本就是过滤文本流。 您有一个来自文件中的行或程序输出的流，您可以通过其他程序进行管道传输。 Unix有一堆专门用于过滤文本的程序（其中一些更 受欢迎的程序在上一章的开头列举）。 使用* nix系统的每个人都可能在某个时刻做过类似的事情：

program-that-prints-something | grep '一种模式'

这是搜索程序输出的“常规”方式，用于包含您正在搜索的内容的行。 你的设置   标准输出   的   程序是版画，东西   到了斯坦丁   grep 。

优秀的CLI脚本应遵循相同的模式，以便将它们合并到shell管道中。 当然，您可以使用自己的“交互式”界面编写脚本，并一次读取一行用户输入：

用户名 = 输入 （ '你叫什么名字？' ）

在某些情况下这很好，但它并没有真正促进可重用，多用途过滤器的创建。 考虑到这一点，请允许我介绍一下   SYS   模块。

该   SYS   模块有各种各样的好东西以及各种你不应该搞砸的东西。 我们将开始   sys.stdin 。

sys.stdin   是一个类似文件的对象，你猜对了，它允许你从脚本中读取   斯坦丁 。 在Bash中你会写：

而 读 线 ; 做 ＃< - 实际上并不安全。 不要使用bash。

“ $ line ”的 东西

DONE

在Python中，它看起来像这样：

导入 系统

在 sys.stdin 行 ：

do_stuff_with（line） ＃< - 我们没有删除换行符char

                        ＃ 时间。 只是提到它，因为它是一个

                        #python和shell之间的区别。

当然，你也可以一口气喝stdin，虽然这不是Unix-y设计的最佳选择，你可以用一个非常大的文件来占用你的RAM：

text = sys.stdin.read（）

就stdout而言，如果你愿意，你可以直接访问它，但你通常只使用   打印（）   功能。

print （ “Hello，stdout。” ）

＃^功能相同：

sys.stdout.write（ 'Hello，stdout。\ n' ）

您打印的任何内容都可以通过管道传输到另一个进程。 管道很棒。 对于stderr来说，这是一个类似的故事：

print （ 'a logging message。' ， file = sys.stderr）

＃ 要么：

sys.stderr.write（ '日志消息。\ n' ）

如果您想要更高级的日志记录功能，请查看   记录模块 。

运用   斯坦丁 ，   标准输出   和   stderr ，你可以编写python程序，它们充当过滤器并很好地集成到Unix工作流程中。

CLI参数

参数作为可以使用的列表传递给您的程序   sys.argv 。 这有点像   $ @   在Bash，或   1美元2美元3美元......   等等：

对于 arg in “ $ @ ” ; 做

“ $ arg ”的 东西

DONE

在Python中看起来像这样：

导入 系统

在 sys.argv中 ARG [1：]：

do_stuff_with（ARG）

为什么   sys.argv [1：] ？   sys.argv中[0]   就好像   $ 0   在Bash或   的argv [0]   在C.这是可执行文件的名称。 只是复习（因为你读了教程，对吧？）   的a_list [1：]   是list-slice语法，它返回从第二项开始的新列表   a_list ，一直到最后。

如果要为CLI程序构建更完整的标志和参数集，则标准库模块就是   argparse 。 该链接中的教程省略了一些有用的信息，所以这里是   API文档 。   点击   是一个流行且功能强大的第三方模块，用于构建更高级的CLI界面。

环境变量和配置文件

好吧，环境变量和配置文件不一定只是CLI界面的一部分，但它们通常是用户界面的一部分，所以我把它们放在这里。 环境变量在   os.environ   映射，所以你去   $ HOME   喜欢这个：

>>> 进口 OS

>>> os.environ [ 'HOME' ]

'/家/ ninjaaron'

就配置文件而言，在Bash中，您经常只在文件中执行一系列变量赋值并将其源化。 您也可以只编写有效的python文件并将它们作为模块导入或评估它们......但不要这样做。 配置文件中的任意代码执行通常不是您想要的。

标准库包括   configparser ，它是.ini文件的解析器，也是一个   JSON   解析器。 我真的不喜欢人类编辑的json的想法，但是如果你愿意的话，继续拍你自己的脚。 至少它很灵活。

PyYAML ，YAML解析器，和   TOML   是对配置文件有用的第三方库。

文件系统的东西

路径

到目前为止，我们只看到路径作为字符串被传递给   打开（）   功能。 你当然可以为你的路径使用字符串   口   和   os.path中   模块包含许多 用于将路径作为字符串进行操作 的 可移植函数。 但是，从Python 3.4开始，我们就有了   pathlib.Path ，一种用于处理文件路径的可移植的抽象类型，它将成为本教程中路径操作的重点。

>>> 来自 pathlib 导入 路径

>>> #make当前目录的路径

>>> p = 路径（）

>>> p

PosixPath（ '。' ）

>>> ＃遍历目录内容

>>> 对于 我 在 p.iterdir（）：

...      打印 （ repr （i））

PosixPath（ '.git' ）

PosixPath（ 'out.html' ）

PosixPath（ 'README.rst' ）]

>>> #use filename globbing

>>> 对于 我 在 p.glob（ '* .rst' ）：

...      打印 （ repr （i））

PosixPath（ 'README.rst' ）

>>> ＃获取完整路径

>>> p = p.absolute（）

>>> p

PosixPath（ '/ home / ninjaaron / doc / replacement-bash-scripting-with-python' ）

>>> ＃获取文件的基名

>>> p.name

'取代-bash的脚本与-蟒'

>>> ＃父目录的名称

>>> p.parent

PosixPath（ '/ home / ninjaaron / doc' ）

>>> ＃将路径拆分为其部分。

>>> p.parts

（ '/'， '家庭'， 'ninjaaron'， 'doc的'， '取代-bash的脚本与-蟒'）

>>> ＃做一些关于路径是什么的测试。

>>> p.is_dir（）

真正

>>> p.is_file（）

假

>>> ＃更详细的文件统计信息。

>>> p.stat（）

os.stat_result（ st_mode = 16877 ， st_ino = 16124942 ， st_dev = 2051 ， st_nlink = 3 ， st_uid = 1000 ， st_gid = 100 ， st_size = 4096 ， st_atime = 1521557933 ， st_mtime = 1521557860 ， st_ctime = 1521557860 ）

>>> ＃使用斜杠创建新的子路径。

>>> 自述 = P / 'README.rst'

>>> 自述

PosixPath（ '/home/ninjaaron/doc/replacing-bash-scripting-with-python/README.rst' ）

>>> ＃打开文件

>>> 将 readme.open（） 作为 file_handle：

...      通过

>>> #make file with mode bits

>>> readme.chmod（ 0o 755 ）

>>> ＃^注意八进制表示法必须是明确的。

再次，查看文档以获取更多信息。   pathlib.Path 。 以来   pathlib   出来后，标准库中越来越多的内置函数和函数将路径名作为字符串参数也可以使用   路径   实例。 如果您发现某个功能没有，或者您使用的是旧版本的Python，则始终可以使用适合您平台的路径获取字符串   str（my_path） 。 如果您需要的文件 操作不是由   路径   例如，检查文档   os.path中   和   口   并看看他们是否可以帮助你。 事实上，   口   如果您正在使用权限和UID等进行系统级别的工作，那么总是一个好的地方。

如果你正在使用   路径   例如，要注意，像ZSH一样   **   可以用于递归的glob。 它（与shell不同）将包括隐藏文件（名称以点开头的文件）。 鉴于此以及您可以进行的其他类型的属性测试   路径   实例，它可以做很多种东西   找   可以做。

>>> [ 在 路径 P P（）。水珠（ '** / *'） 如果 p.is_dir（）]

哦。 差点忘了。   p.stat（） ，如你所见，返回一个   os.stat_result   实例。 有一点需要注意的是   st_mode （即权限位）表示为整数，因此您可能需要执行类似的操作   辛（p.stat（）。ST_MODE）   显示八进制数字的大小，这就是你设置它的方式   CHMOD   在壳中。

替换杂项文件操作：   shutil

在shell中有一些非常简单的文件操作，但是如果你使用的是python文件对象或基本的系统调用，那么你可能认为不太好。   口   模块。 当然，您可以使用重命名文件   os.rename（） ，但如果你使用   MV   在shell中，它将检查您是否正在移动到另一个文件系统，如果是，则复制数据并删除源 - 它可以递归地执行此操作而不用大惊小怪。   shutil   是填补空白的标准库模块。 docstring给出了一个很好的总结：“用于复制和归档文件和目录树的实用程序功能。”

这是概述：

>>> import shutil

>>> ＃$ mv src dest

>>> shutil.move（ 'src' ， 'dest' ）

>>> ＃$ cp src dest

>>> shutil.copy2（ 'src' ， 'dest' ）

>>> ＃$ cp -r src dest

>>> shutil.copytree（ 'src' ， 'dest' ）

>>> ＃$ rm a_file

>>> os.remove（ 'a_file' ） ＃ok，这不是shutil

>>> ＃$ rm -r a_dir

>>> shutil.rmtree（ 'a_dir' ）

>>> ＃$ tar caf'my_archive.tar.gz''my_folder'

>>> shutil.make_archive（ 'my_archive.tar.gz' ， 'gztar' ， 'my_folder' ）

>>> ＃$ tar xaf'my_archive.tar.gz'

>>> shutil.unpack_archive（ 'my_archive.tar.gz' ）

>>> #chown user：ninjaaron a_file.txt

>>> shutil.chown（ 'a_file.txt' ， 'ninjaaron' ， 'user' ）

>>> 有关磁盘使用情况的信息，有点像`df`，但不完全正确。

>>> shutil.disk_usage（ '。' ）

用法（ 总计 = 123008450560 ， 使用 = 86878904320 ， 免费 = 36129546240 ）

>>> ＃^大小以字节为单位

>>> ＃哪个vi

>>> shutil.which（ 'vi' ）

'在/ usr / bin中/ VI'

>>> ＃关于您正在运行的终端的信息。

>>> shutil.get_terminal_size（）

os.terminal_size（ 列 = 138 ， 行 = 30 ）

这是你通常会使用的高级功能的千尺远视图。 模块文档非常适用于示例，但它也有很多 关于用于实现我所展示的更高级别的东西的函数 的 细节，这些函数可能有趣也可能没有。

我也应该提一下   os.link   和   os.symlink   在此刻。 他们分别创建硬链接和软链接（如   链接 和   链接-s   在壳中）。   路径   实例也有   .symlink_to（）   方法，如果你想要的话。

更换   sed ，   grep ，   awk 等：Python正则表达式

对于那些已经或多或少知道如何在其他“普通”语言中使用正则表达式进行匹配和字符串操作的有经验的程序员来说，这一部分并不多。 Python在这方面并不是那么特别，但如果你已经习惯了JavaScript，Ruby，Perl等，你可能会惊讶地发现Python没有正则表达式文字。 功能上正则表达式都封装在   回覆   模块。 （官方文档有一个   正则表达式HOWTO ，如果你对正则表达式一无所知，这是一个很好的起点。 如果你有一些经验，我建议你直接去   回覆   API文档。）

本节适用于知道如何使用程序的人   sed ，   grep的   和   AWK   并希望在Python中获得类似的结果，尽管将提供这些实用程序常用的简短说明。

我承认在Python中编写简单的文本过滤器永远不会像在Perl中那样优雅，因为Perl或多或少被创建为类似于超级驱动版本的   SH   +   AWK   +   sed 。 可以说同样的事情   awk ，Unix上的原始文本过滤语言。 使用Python执行这些任务的主要原因是，当您想要执行更复杂的操作时，项目将更容易扩展。

要记住的另一件事是python具有内置操作，如果您只需要匹配字符串而不是正则表达式，则可以使用它。 简单的字符串操作比正则表达式快得多，但功能不强。

注意

有一点需要注意的是，Python的正则表达式更像是PCRE（Perl风格 - 也类似于Ruby，JavaScript等），而不是大多数shell实用程序支持的BRE或ERE。 如果你主要做的话   SED   要么   grep的   没有   -E   选项，你可能想看看Python正则表达式的规则（BRE是你知道的正则表达方言）。 如果你习惯写正则表达式   AWK   要么   egrep的   （ERE），Python正则表达式或多或少是你所知道的超集。 您仍然可以查看文档，了解一些您可以执行的更高级的操作。 如果你知道来自vi / Vim或Emacs的正则​​表达式，他们都使用他们自己的正则表达方言，但它们是BRE的超集，而Python的正则表达式会有一些主要的区别。

如何   grep的

grep的   是Unix实用程序，它遍历文件的每一行，测试它是否包含某种模式，然后打印匹配的行。 如果你是一名程序员并且你 没有使用   grep ，开始使用它！ 使用Python可以轻松检索文件中的匹配行，因此我们将从那里开始。

如果你不需要模式匹配（即你可以做的事情   fgrep ），你不需要正则表达式匹配子字符串。 您可以简单地使用内置语法：

>>> “子” 在 '包含子字符串的字符串'

真正

否则，您需要正则表达式模块来匹配的东西：

>>> 进口 重新

>>> re.search（R '的图案'，R '串包含图案'）

< _sre。 SRE_Match 对象 ; 跨度 =（18，27），匹配 = '的图案'>

>>> re.search（R '的图案'，R '串而不图案'）

>>> ＃返回None，不在Python REPL中打印

我不打算详细介绍目前返回的“匹配对象”。 现在最重要的是它评估为   真正   在布尔上下文中。 您可能还会注意到我使用原始字符串   r'' 。 这是为了防止Python的正常转义序列被解释，因为正则表达式使用它自己的转义。

因此，要使用这些来过滤字符串：

>>> ics = an_iterable_containing_strings

>>> #like fgrep

>>> 过滤 =（一个或多个 对于 s 在 ICS 中 ，如果 子串 以 s）

>>> #like grep（或者更像是egrep）

>>> 过滤 =（一个或多个 对于 s 在 ICS 中 ，如果 re.search（图案，S））

an_iterable_containing_strings   这里可以是列表，生成器甚至文件/文件类对象。 迭代它时会给你一些字符串的东西。 我用   发电机表达   语法在这里而不是列表理解，因为这意味着每个结果都是根据需要通过延迟评估生成的。 如果您正在使用大文件，这将保存您的RAM。 你可以反转结果，比如   grep -v   只需添加   不   到了   如果   条款。 还有一些标志可以添加来做一些事情，例如忽略大小写（ flags = re.I ）等。查看文档了解更多信息。

示例：搜索日志以查找错误

假设您要查看系统上某个服务的日志文件是否存在错误。 使用grep，您可能会执行以下操作：

$ grep -i error：/var/log/some_service.log

这将搜索   /var/log/some_service.log   对于包含该字符串的任何行   错误： ，忽略大小写。 在Python中做同样的事情：

同 打开 （ '/var/log/some_service.log' ） 作为 日志：

匹配 =（线 在 日志 如果 线 '错误：' 在 line.lower（））

    在这种情况下，＃line.lower（）是grep中-i的替代品

这里的区别在于bash版本将打印所有行，而python版本只是持有它们以进行进一步处理。 如果要打印它们，下一步就是   打印（*匹配）   要么   对于匹配中的行：print（line，end =''） 。 但是，这是在脚本的上下文中，因此您可能希望从该行中提取更多信息，并以任何方式以编程方式执行某些操作。

如何   SED

SED   可以做很多事情。 它或多或少是没有窗口的“文本编辑器”。 你给出的不是手动编辑文本   关于修改 SED 指令适用于线，它确实这一切在一杆。 （默认情况下是通过修改打印文件的样子。除非使用特殊标志，否则文件实际上不会更改。）

我不会涵盖所有这些。 当我编写更多shell脚本而不是Python时，我的绝大部分用途都是   sed 只是使用替换工具将一个模式的实例更改为其他模式，这就是我在这里介绍的内容。

>>> #sed's /一个字符串/另一个字符串/ g' - 即不是正则表达式

>>> 替换 = （s.replace（ '一个字符串' ， '另一个字符串' ） for s in ics）

>>> #sed /s / replacement / g' - 需要正则表达式

>>>（ICS 中 应用re.sub（R '模式'，R '替换'，S）， 用于 多个 ） 替换 =

应用re.sub   有很多附加功能，包括使用能力   函数而不是字符串   替换参数。 我认为这非常有用。 如果您是regex的新手，请特别注意有关替换中的反向引用的部分。 您可以查看中的部分   正则表达式HOWTO   关于   搜索和替换   同样。

如何   AWK

该   SED   部分需要一点免责声明。 该   AWK   部分需要更大的部分。 AWK是图灵完备的文本/表格处理语言。 我不打算介绍AWK如何处理Python习语所能完成的任务。

但是，在shell脚本中，它最常用于从表格数据中提取字段，例如tsv文件。 基本上，它用于分割字符串。

>>> #awk'{print $ 1}'

>>> field1 = （f [ 0 ] for f in （s.split（） for s in ics））

>>> #awk -F：'{print $ 1}'

>>> field1 = （f [ 0 ] for f in （s.split（ '：' ） for s in ics））

>>> #awk -F'[^ a-zA-Z]''{print $ 1}'

>>> field1 = （f [ 0 ] for f in （re.split（ r '[ ^ a-zA-Z ]' ，s） for s in ics））

正如在这个例子中暗示的那样   str.split   默认情况下，方法在连续的空格的部分上进行拆分。 否则，它将分割为作为分隔符给出的任何内容。 有关使用正则表达式拆分的更多信息，请参阅   re.split   和   分裂字符串 。

运行进程

我在教程结束时来到本节，因为一个   通常不应该在Python脚本中运行很多进程 。 但是，很多时候应该打破这个“规则”。 假设您想对系统上的软件包进行一些自动化; 你会坚持不使用   易于   要么   百胜   （拼写   DNF   这些天）或任何你的包经理。 如果你正在做同样适用   的mkfs   或使用非常成熟和功能强大的程序   rsync 。 我的一般规则是应该避免使用任何类型的过滤实用程序，但是用于操作系统的专用程序是公平的游戏 - 但是，在某些情况下，会有一个第三方Python 库提供底层C代码的包装器。 当然，在大多数情况下，库会比产生新过程更快。 用你最好的判断。 如果您正在尝试编写可重用的库代码，请务必谨慎。

有许多功能不得在其中命名   口   可用于生成进程的模块。 他们有各种各样的问题。 一些在子壳中运行过程（参见注入漏洞）。 有些是libc中系统调用的瘦包装器，如果您实现自己的流程库，可能需要使用它，但使用起来并不是特别有趣。 有些只是遗留原因的旧接口，实际上已经在您应该使用的新模块（ 子进程）之上重新实现。对于管理脚本，只需直接使用子流程。     

本教程重点介绍如何使用 Popen构造函数和run函数，后者仅在Python 3.5中添加。如果您使用的是Python 3.4或更早版本，则需要使用旧的API，尽管这里所说的很多内容仍然具有相关性。         

该   Popen API（运行函数是一个瘦包装器）是一个非常灵活，安全设计的界面，用于运行进程。最重要的是，默认情况下它不会打开子shell。这是正确的，它完全可以防止shell注入漏洞 - 或者，注入漏洞是选择性的。如果您决定编写错误的代码，那么总是有shell = True 选项。         

另一方面，使用起来有点麻烦，因此有很多第三方库可以简化它。 Plumbum可能是其中最受欢迎的。萨格也不错。我自己对该领域的贡献是easyproc（尽管文档需要完全重写）。           

还有一些Python超集允许在python代码中内联shell命令。 xonsh是一个，它还提供了一个功能齐全的交互式系统shell体验，并且是每次打开终端时运行的程序。我强烈推荐它！   

无论如何，随着节目。

>>> 导入子为SP

>>> sp.run（[ 'ls' ， ' - lh' ]）

总计 104K

- RW - - [R - - [R - 1个ninjaaron用户69K Mar的21 16 ：40 out.html

- RW - [R - [R - 1个ninjaaron用户32K Mar的23 11 ：11 自述.rst

CompletedProcess（ args = [ 'ls' ， ' - lh' ]， returncode = 0 ）

如您所见，run函数的第一个也是唯一必需的参数是命令参数的列表（或任何其他可迭代的）。stdout没有被捕获，它只是在脚本的stdout去的地方。返回的是CompletedProcess实例，它具有 args 属性和returncode 属性。当某些关键字参数与run 一起使用时，也可能有更多属性可用。         

处理退出代码

与Python中的大多数其他内容不同，默认情况下失败的进程不会引发异常。

>>> sp.run（[ 'ls' ， ' - lh' ， 'foo bar baz' ]）

ls：无法访问 'foo bar baz' ：没有这样的 文件 或目录

CompletedProcess（ args = [ 'ls' ， ' - lh' ， 'foo bar baz' ]， returncode = 2 ）

这与它在shell中的工作方式相同。但是，如果命令不起作用，或者至少尝试其他操作，通常会希望脚本停止。您可以手动执行此操作：

>>> proc = sp.run（[ 'ls' ， ' - lh' ， 'foo bar baz' ]）

ls：无法访问 'foo bar baz' ：没有这样的 文件 或目录

>>> 如果proc.returncode ！= 0 ：

...... ＃做别的事    

在非零退出代码表示错误以外的情况下，这将是最有用的。例如， 如果没有匹配的行，grep 返回1 。这不是一个错误，而是您可能想要检查的内容。     

但是，在大多数情况下，您可能希望使用非零退出代码来破坏程序，尤其是在开发期间。这是你需要的地方   查   参数：

>>> sp.run（[ 'ls' ， ' - lh' ， 'foo bar baz' ]， check = True ）

回溯（最近的呼叫最后）：

文件 “<标准输入>” ，线 1 ， 在 < 模块>

文件 “/usr/lib/python3.6/subprocess.py” ，第 418 行， 在 运行中

output = stdout，stderr = stderr）

subprocess.CalledProcessError：命令 '[' LS ' ' - LH '，' FOO酒吧巴兹 ']' 返回非 - 零 退出 状态 2 。

命令 '[' LS ' ' - LH '，' 富酒吧巴兹 ']' 返回非 - 零 退出 状态 2 。

好多了！ 如果愿意，您现在也可以使用普通的Python 异常处理。   

重定向进程IO（即管道）

如果要捕获进程的输出，则需要使用 stdout 参数。如果你想将它重定向到一个文件，它非常简单：   

>>> 同 开放 （ './foo' ， 'W' ） 为 foofile：

... sp.run（[ 'ls' ]， stdout = foofile）

与输入非常相似：

>>> 同 打开 （ 'foo' ） 作为 foofile：

... sp.run（[ 'tr' ， 'a-z' ， 'A-Z' ]， stdin = foofile）

...

FOO

OUT 。 HTML

自述文件 。 RST

如果要在脚本本身内部对输入和输出文本执行某些操作，则需要使用特殊常量 subprocess.PIPE 。 

>>> PROC = sp.run（[ 'LS' ]， 标准输出 = 属 管 ）

>>> print （proc.stdout）

b '富\ nout.html \ nREADME.rst \ N'

现在怎么样？啊对。进程和来自进程的流默认为字节，而不是字符串。你可以解码你的字符串，或者你可以使用该标志来确保流是一个 python字符串，这是他们无限的智慧， 子进程模块的作者选择调用universal_newlines ，就好像这是字节和字符串之间最重要的区别在Python中。更新：从Python 3.7开始，`universal_newlines`别名为`text`       

>>> PROC = sp.run（[ 'LS' ]， 标准输出 = 属 PIPE ， universal_newlines = 真 ）

>>> print （proc.stdout）

FOO

out.html

自述 .rst

所以这很尴尬。事实上，这种疯狂是我编写 easyproc的主要动机之一。 

如果要将字符串传递给进程的stdin，则将使用不同的 运行参数input （同样，除非universal_newlines = True ，否则需要字节）。         

>>> sp.run（[ 'tr' ， 'a-z' ， 'A-Z' ]， input = 'foo bar baz \ n' ）

回溯（最近的呼叫最后）：

文件 “<标准输入>” ，线 1 ， 在 < 模块>

文件 “/usr/lib/python3.6/subprocess.py” ，第 405 行， 在 运行中

stdout，stderr = process.communicate（ 输入 ， 超时 = 超时）

文件 “/usr/lib/python3.6/subprocess.py” ，第 828 行， 进行 通信

    self ._stdin_write（ 输入 ）

文件 “/usr/lib/python3.6/subprocess.py” ，第 781 行， 在 _stdin_write中

    self .stdin.write（ 输入 ）

类型错误 ：一个 字节 - 像 对象 是必须的，不“STR”

一个 字节 - 像 对象 是必须的，不“STR”

>>>

>>> ##只做感觉......

>>>

>>>

>>> sp.run（[ 'tr' ， 'a-z' ， 'A-Z' ]， input = 'foo bar baz \ n' ， universal_newlines = True ）

FOO BAR BAZ

CompletedProcess（ args = [ 'tr' ， 'a-z' ， 'A-Z' ]， returncode = 0 ）

该 标准错误参数   

就像有一个stdout参数一样，还有一个stderr参数用于处理来自进程的消息。它按预期工作：

>>> 同 open （ 'foo.log' ， 'w' ） 作为 日志文件：

... sp.run（[ 'ls' ， 'foo bar baz' ]， stderr = logfile）

...

>>> sp.run（[ 'LS' ， '富酒吧巴兹' ]， 标准错误 = 属 PIPE ）.stderr

b “ls：无法访问'foo bar baz'：没有这样的文件或目录\ n”

然而，在管理脚本中与stderr有关的另一个常见的事情是使用 2>＆1 的令人难忘的咒语shell咒语将它与stdout结合起来。subprocess 也有这样的东西，STDOUT 常量。         

>>> PROC = sp.run（[ 'LS' ， '' ， '富酒吧巴兹' ]， 标准输出 = 属 PIPE ， 标准错误 = 属 STDOUT ）

>>> print （proc.stdout.decode（））

ls：无法访问 'foo bar baz' ：没有这样的 文件 或目录

。：

FOO

foo.log

out.html

自述 .rst

您还可以使用常量 subprocess.DEVNULL 将stdout和stderr重定向到/ dev / null 。 

你可以用 run函数做更多的事情，但这应该足以让你继续使用。   

后台进程和并发

subprocess.run 启动一个进程，等待它完成，然后返回一个CompletedProcess 实例，该实例包含有关所发生事件的信息。在大多数情况下，这可能是您想要的。但是，如果您希望进程在后台运行或需要在它们继续运行时与它们进行交互，则需要Popen构造函数。         

如果您只是想在继续编写脚本时在后台启动一个进程，那就像 运行一样。 

>>> ##爆米花的时间......

>>> sp.Popen（[ 'mpv' ， '星际迷航II：Kahn.mkv的愤怒' ]）

< subprocess.Popen 对象 在 0X 7fc35f4c0668 >

>>> ##和脚本继续我们欣赏节目...

这与使用 ＆在shell中处理进程并不完全相同。我没有研究过技术上会发生什么，但我可以告诉你，即使从它开始的终端关闭，这个过程也会继续进行。这有点像nohup 。但是，如果未重定向，stdout和stderr仍将打印到该终端。   

执行此操作的其他原因可能是在您需要输出的脚本开头处启动进程，然后稍后再返回以最小化等待时间。例如，我使用Python脚本生成我的ZSH提示。除此之外，此脚本还会检查文件夹的git状态。但是，这可能需要一些时间，我希望脚本在等待这些命令时尽可能多地完成工作。

##靠近脚本顶部的地方：

branch_proc = sp.Popen（[ 'git的' ， '分支' ]， 标准输出 = 属 管 ，

                       stderr = sp。 DEVNULL ， universal_newlines = True ）

status_proc = sp.Popen（[ 'git的' ， '状态' ， '-s' ]， 标准输出 = 属 管 ，

                       stderr = sp。 DEVNULL ， universal_newlines = True ）

 

## ...进一步向下：

 

branch = [i for i in branch_proc.stdout if i.startswith（ '*' ）] [ 0 ] [ 2 ： - 1 ]

颜色 = “红色” 如果status_proc.stdout.read（）其他“绿色”

请注意， 在这种情况下，stdout 不是字符串。它是一个类似文件的对象。这非常适合逐行处理程序的输出，就像许多系统实用程序一样。如果程序产生大量输出并将整个内容读入Python字符串可能会占用大量RAM，这一点尤为重要。它对于长时间运行的程序也很有用，这些程序可能会缓慢地产生输出，但是你想要在它来时处理它。例如：   

>>> ＃实际上并没有在Python中使用`find`。Path.glob和os.walk

>>> ＃更好。

>>> 与sp.Popen（[ '发现' ，'/' ]，标准输出= 属管，

... universal_newlines = True ）作为proc：               

...... 对于线在proc.stdout：    

... do_stuff_with（line）

您也可以使用此机制将进程一起管道，尽管在python中需要执行此操作的情况应该很少，因为文本筛选最好在python本身中完成。您可能希望将进程一起管道的情况可能是提取rpm包的内容：

>>> ＃rpm2cpio a_package.rpm | cpio -idm

>>> R2C = sp.Popen（[ 用'rpm2cpio' ， 'a_package.rpm' ]， 标准输出 = 属 管 ）

>>> sp.run（[ 'cpio' ， ' - idm' ]， stdin = r2c.stdout）

shlex.quote ：防止外壳注入

该   如前所述，子进程模块默认情况下是安全的，除非使用shell = True 。但是，有些程序会在shell启动后为shell提供参数。SSH是一个典型的例子。您使用ssh发送的每个参数都会被远程系统上的shell解析。     

一旦进程获得shell，您就放弃了首先使用Python的一个主要好处。您将重新回到注入漏洞的领域。

基本上，而不是这个：

>>> sp.run（[ 'ssh' ， 'user @ host' ， 'ls' ，path]）

你需要做这样的事情：

>>> 进口shlex

>>> sp.run（[ 'ssh' ， 'user @ host' ， 'ls' ，shlex.quote（path）]）

shlex.quote 将确保正确转义任何空格或shell元字符。唯一的麻烦就是你实际上必须记得使用它。 

该   shlex 模块还有一个split 函数，它将字符串拆分为一个列表，就像shell拆分参数一样。如果您有一个看起来像shell命令的字符串并且想要将其发送到subprocess.run，这将非常有用          要么   subprocess.Popen 。

杂

这就是本教程中所有内容并不需要详细介绍的内容，但是在shell脚本中需要经常做的事情是它需要指向其他资源的指针。

获得时间

在管理脚本中，人们经常希望在文件名中添加时间戳以命名日志或其他任何内容。在shell脚本中，您只需使用 date 的输出即可。Python有两个用于处理时间的库，其中任何一个都足以处理这个问题。    该   time 模块在libc中包装时间函数。如果你想从中获取时间戳，你可以这样做： 

>>> 进口时间

>>> time.strftime（ '％Y。％m。 ％d ' ）

“2018年8月18日”

这可以使用您在运行 $ man date 时看到的任何格式规范。还有一个time.strptime 函数，它将字符串作为输入，并使用相同类型的格式字符串来解析它的时间并进入元组。     

该   datetime 模块提供了在高级别处理时间的类。这对于非常简单的事情来说有点麻烦，并且对于涉及时间的数学等更复杂的事情非常有帮助。它可以为我们的案例做的一件好事是给我们一个当前时间的字符串，而不需要格式说明符。 

>>> 导入日期时间

>>> ＃将当前时间作为日期时间对象

>>> datetime.datetime.now（）

datetime.datetime（ 2018 ， 8 ， 18 ， 10 ， 5 ， 56 ， 518515 ）

>>> now = _

>>> str （现在）

'2018-08-18 10：05：56.518515'

>>> now.strftime（ '％Y。％m。 ％d ' ）

“2018年8月18日”

这意味着，如果您对datetime类的默认字符串表示感到满意，则可以执行 str（datetime.datetime.now（））来获取当前时间戳。还有一个datetime.datetime.strptime（）用于从时间戳生成日期时间实例。       

进程间通信

我不确定IPC是否真的是bash脚本的一部分，但有时管理员可能需要编写一个守护进程或在后台运行的任何东西，但仍然能够通过客户端接收用户的通信。

最简单的方法是使用fifo，也就是命名管道。

进口 OS

 

myfifo = '/ tmp / myfifo'

os.mkfifo（myfifo）

尝试 ：

    而 真：

        同 打开 （myfifo） 为 fh：

do_something（fh.read（））

除了 ：

os.remove（myfifo）

    提高

这是您从init系统开始的服务器。最简单的客户端可能只是回声; 回显一些文字> / tmp / myfifo 。当然，如果你愿意，你可以与客户做更多的事情。fifo的限制是它是单向通信。如果你想双向，你需要两个fifos。或者，使用TCP套接字。 

Python有一个简单的用于创建套接字服务器的库，恰当地命名为 socketserver。向下滚动到示例，它们基本上包含了实现服务器和客户端所需的一切。对于您刚刚通过localhost进行交互的守护进程，使用UnixStreamServer 类可以获得更好的性能，并且不会耗尽端口。另外，Unix套接字会让你的Unix胡须变得更好。     

其中任何一个的问题是它们只是阻塞直到它们收到消息（除非你使用线程套接字服务器，在某些情况下可能没问题）。如果您希望守护进程在同时监听输入的同时工作，则需要线程或asyncio。不幸的是，本教程是关于用Python替换Bash，我不打算教你并发。

注意

我只想说python线程模块适用于小规模的IO绑定多任务处理。如果您需要大规模的东西，请使用asyncio。如果您需要真正的并发执行，请知道Python线程是谎言，而asyncio不会这样做。你需要多处理。如果您需要并发执行，但进程太昂贵，请使用其他编程语言。Python在这方面有局限性。

下载网页和文件

如果您正在做任何需要诸如与API交互，拍摄数据，进行身份验证或基本上除了下载静态资产之外的任何内容的http请求，请使用 请求。事实上，您甚至应该将它用于下载内容的简单情况。但是，标准库也可以实现这一点，并不是特别痛苦。 

为此，您需要 urllib.request。 

 